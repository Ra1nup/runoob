# C++ 跳转语句知识点详解

## 🔀 跳转语句概述
跳转语句用于改变程序的正常执行流程，包括`break`、`continue`和`goto`三种类型。合理使用跳转语句可以简化代码逻辑，但滥用会降低代码可读性。

## 1. break 语句
### 功能与特点
- 立即终止**最内层**的`switch`或循环语句（`while`、`do-while`、`for`）
- 执行流跳转到被中断语句后的第一条语句
- 主要用于：
  - 提前结束循环
  - 跳出switch语句
  - 中断死循环

### 应用案例
```cpp
// 案例1：在switch中跳出
int day = 3;
switch(day) {
    case 1: cout << "周一"; break;  // 必须添加break
    case 2: cout << "周二"; break;
    case 3: cout << "周三"; break;  // 执行后跳出switch
    default: cout << "无效";
}
// 程序继续执行此处

// 案例2：提前结束循环
for (int i = 1; i <= 100; i++) {
    if (i * i > 500) {
        cout << "超过500的第一个平方数是: " << i*i;
        break;  // 达到条件立即终止循环
    }
}

// 案例3：死循环中断
int count = 0;
while (true) {  // 无限循环
    count++;
    if (count >= 1000) {
        cout << "达到1000次计数";
        break;  // 安全出口
    }
}
```

## 2. continue 语句
### 功能与特点
- 跳过当前循环迭代的**剩余部分**
- 立即开始下一次循环迭代
- 不会终止整个循环
- 主要用于：
  - 跳过特定条件的迭代
  - 优化循环性能

### 应用案例
```cpp
// 案例1：跳过特定数字
for (int i = 1; i <= 10; i++) {
    if (i % 3 == 0) {
        continue;  // 跳过3的倍数
    }
    cout << i << " ";  // 输出: 1 2 4 5 7 8 10
}

// 案例2：处理有效数据
int sum = 0;
for (int i = 0; i < 10; i++) {
    int value;
    cout << "输入第" << i+1 << "个值: ";
    cin >> value;
    
    if (value <= 0) {
        cout << "无效值，跳过！" << endl;
        continue;  // 跳过非正数
    }
    sum += value;  // 仅累加有效值
}

// 案例3：嵌套循环中的continue
for (int i = 1; i <= 3; i++) {
    for (int j = 1; j <= 3; j++) {
        if (j == 2) {
            continue;  // 跳过内层循环的j=2迭代
        }
        cout << "i=" << i << ", j=" << j << endl;
    }
}
/* 输出：
i=1, j=1
i=1, j=3
i=2, j=1
i=2, j=3
i=3, j=1
i=3, j=3 */
```

## 3. goto 语句
### 功能与特点
- 无条件跳转到同一函数内的**标签**处
- 语法：`goto 标签; ... 标签: 语句;`
- 争议性：
  - 优点：快速退出多层嵌套
  - 缺点：破坏程序结构，降低可读性（被称为"面条代码"）
- 使用建议：
  - 避免使用，除非有充分理由
  - 仅用于跳出深层嵌套结构
  - 不要用于循环控制（用break/continue代替）

### 应用案例
```cpp
// 案例1：错误处理中跳出多层嵌套
for (int i = 0; i < 5; i++) {
    for (int j = 0; j < 5; j++) {
        for (int k = 0; k < 5; k++) {
            if (someCriticalError()) {
                goto error_handling;  // 直接跳转到错误处理
            }
            // 正常处理代码
        }
    }
}

error_handling:
cerr << "发生严重错误！" << endl;
// 错误处理代码...

// 案例2：替代多个break（不推荐）
int count = 0;
start_point:  // 标签
count++;
if (count < 10) {
    goto start_point;  // 模拟循环
}
cout << "计数结束: " << count;

// 案例3：有限状态机（合理使用场景）
void process() {
    STATE state = INIT;
    
    init_state:
        // 初始化代码...
        state = PROCESSING;
    
    processing_state:
        // 处理代码...
        if (needReset) goto init_state;
        state = FINAL;
    
    final_state:
        // 清理代码...
}
```

## ⚖️ 跳转语句对比表

| 特性         | break          | continue       | goto             |
|--------------|----------------|----------------|------------------|
| **作用范围** | 当前循环/switch | 当前循环迭代   | 同一函数内任意位置 |
| **循环影响** | 终止整个循环   | 跳过当前迭代   | 无直接影响       |
| **推荐指数** | ★★★★★          | ★★★★☆          | ★☆☆☆☆            |
| **适用场景** | 提前结束循环   | 跳过特定迭代   | 深层嵌套跳出     |
| **可读性**   | 高             | 中             | 低               |

## 🚫 跳转语句使用禁忌

### 1. 避免在循环外使用break/continue
```cpp
// 错误示例
if (condition) {
    break;  // 错误：break不能在循环外使用
}
```

### 2. 避免goto滥用导致"面条代码"
```cpp
// 反面教材：难以理解的流程
goto step3;
step1: ... goto step4;
step2: ... goto step1;
step3: ... goto step2;
step4: ...
```

### 3. 不要用goto跳过变量初始化
```cpp
int x;
goto jump;  // 合法但危险

int y = 10; // 初始化
jump:
cout << y;  // 错误！y可能未初始化
```

## 🛠 替代方案与最佳实践

### 1. 使用函数代替goto
```cpp
// 使用goto
if (error1) goto cleanup;
// ...
if (error2) goto cleanup;

cleanup:
// 清理代码

// 更佳方案：封装为函数
void cleanupResources() { /* 清理代码 */ }

if (error1) {
    cleanupResources();
    return;
}
// ...
if (error2) {
    cleanupResources();
    return;
}
```

### 2. 使用标志变量替代深层嵌套break
```cpp
bool found = false;  // 标志变量
for (int i = 0; i < 10 && !found; i++) {
    for (int j = 0; j < 10 && !found; j++) {
        if (matrix[i][j] == target) {
            found = true;
            // 不需要goto或break多层
        }
    }
}
```

### 3. 异常处理替代错误跳转
```cpp
try {
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            if (criticalCondition) {
                throw CriticalException("错误发生");
            }
        }
    }
} catch (const CriticalException& e) {
    cerr << e.what() << endl;
    // 错误处理
}
```

## 📊 实际应用案例

### 案例1：文件处理中的break
```cpp
ifstream file("data.txt");
if (!file.is_open()) {
    cerr << "文件打开失败";
    return;
}

string line;
while (getline(file, line)) {
    if (line.empty()) {
        cout << "遇到空行，停止读取";
        break;  // 提前结束文件读取
    }
    cout << line << endl;
}
file.close();
```

### 案例2：数据过滤中的continue
```cpp
vector<int> data = {15, -2, 30, 0, 42, -10, 7};
int positiveSum = 0;

for (int num : data) {
    if (num <= 0) {
        continue;  // 跳过非正数
    }
    
    // 复杂计算（仅对正数执行）
    double sqrtVal = sqrt(num);
    if (sqrtVal > 5) {
        positiveSum += num;
    }
}

cout << "符合条件的正数和: " << positiveSum;
```

### 案例3：合理使用goto（资源清理）
```cpp
void processFile(const char* filename) {
    FILE* f = fopen(filename, "r");
    if (!f) goto error;
    
    char* buffer = new char[1024];
    if (!buffer) goto cleanup_file;
    
    // 文件处理逻辑...
    if (processFailed()) goto cleanup_buffer;
    
    delete[] buffer;
    fclose(f);
    return;

// 错误处理路径（自上而下清理）
cleanup_buffer:
    delete[] buffer;
cleanup_file:
    fclose(f);
error:
    cerr << "文件处理失败: " << filename;
}
```

> **💡 跳转语句使用原则**  
> 1. **优先使用break/continue**：比goto更安全、可读性更高  
> 2. **限制goto使用**：仅在深层嵌套资源清理等特殊场景使用  
> 3. **保持标签可见**：goto标签应放在函数末尾，自上而下清理  
> 4. **添加充分注释**：解释使用跳转语句的原因  
> 5. **考虑替代方案**：函数封装、异常处理、状态变量等